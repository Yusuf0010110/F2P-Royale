<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clash-esque — Playable vs Bot + Upgrades</title>
<style>
  :root{
    --bg:#0a1220;
    --panel:#0f2233;
    --card:#122a3b;
    --accent:#2fb0ff;
    --accent2:#ffd46b;
    --muted:#98b8d0;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Helvetica,Arial;background:var(--bg);color:#e6f7ff}
  .app{max-width:1100px;margin:14px auto;padding:12px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{margin:0;font-size:18px;color:var(--accent)}
  .top-right{display:flex;gap:8px;align-items:center}
  .pill{background:var(--panel);padding:8px 12px;border-radius:10px;font-size:13px;color:var(--muted)}
  nav{display:flex;gap:10px;margin:10px 0}
  nav button{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer}
  nav button.active{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);color:white;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
  .layout{display:flex;gap:12px}
  .left{flex:1}
  .right{width:320px}
  /* arena */
  .board-wrap{background:linear-gradient(180deg,#09202e,#071427);padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
  #arena{width:100%;height:560px;border-radius:10px;display:block;background:linear-gradient(180deg,#063047,#01202a);box-shadow:inset 0 8px 40px rgba(0,0,0,0.6)}
  .controls{display:flex;align-items:center;justify-content:space-between;margin-top:10px}
  .cards-row{display:flex;gap:10px}
  /* card look */
  .card-ui{
    width:120px;background:linear-gradient(180deg,#0c2b3f,#09202e);border-radius:12px;padding:8px;border:1px solid rgba(255,255,255,0.04);
    display:flex;flex-direction:column;align-items:center;cursor:pointer;box-shadow:0 6px 16px rgba(0,0,0,0.6);
  }
  .card-ui.selected{outline:3px solid rgba(47,176,255,0.12);transform:translateY(-4px)}
  .card-thumb{width:84px;height:64px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.04),transparent);display:flex;align-items:center;justify-content:center;font-weight:700}
  .card-name{font-weight:700;margin-top:8px}
  .card-meta{display:flex;gap:8px;margin-top:6px;font-size:13px;color:var(--muted)}
  .cost-bubble{background:linear-gradient(180deg,var(--accent),#1c8fe0);padding:6px 8px;border-radius:10px;color:white;font-weight:700}
  .small{font-size:13px;color:var(--muted)}
  button.primary{background:var(--accent);border:none;padding:8px 12px;border-radius:10px;color:white;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
  /* right panel cards list */
  .panel{background:var(--panel);padding:12px;border-radius:10px}
  .upgrade-row{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px}
  .statbar{height:8px;background:#072434;border-radius:8px;overflow:hidden}
  .statbar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
  /* chest / trophy */
  .chest{display:flex;align-items:center;gap:8px;padding:8px;background:linear-gradient(180deg,#193041,#102431);border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
  .tabs{display:flex;gap:6px;margin-bottom:8px}
  .muted{color:var(--muted)}
  /* responsive */
  @media(max-width:980px){
    .layout{flex-direction:column}
    .right{width:100%}
    #arena{height:460px}
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Clash-ish — Arena · Cards · Upgrades ⚔️</h1>
      <div class="top-right">
        <div class="pill">Gold: <span id="goldDisplay">0</span></div>
        <div class="pill">Trophies: <span id="trophyDisplay">0</span></div>
      </div>
    </header>

    <nav>
      <button id="tabBattle" class="active">Battle</button>
      <button id="tabCards">Cards</button>
      <button id="tabChests">Chests</button>
    </nav>

    <div class="layout">
      <!-- LEFT: Arena & controls -->
      <div class="left">
        <div class="board-wrap">
          <canvas id="arena" width="860" height="560"></canvas>
        </div>

        <div class="controls">
          <div class="cards-row" id="cardsRow"></div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="ghost" id="autoPlayBtn">Auto Bot: ON</button>
            <button class="primary" id="restartBtn">Restart Match</button>
          </div>
        </div>
      </div>

      <!-- RIGHT: info / upgrades / chests -->
      <div class="right">
        <div id="panelBattle" class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Match</strong><div class="small muted">Bottom = you · Top = enemy</div></div>
            <div class="small muted" id="matchTimer">00:00</div>
          </div>
          <hr style="margin:8px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)"/>
          <div><strong>Towers</strong></div>
          <div id="towerStatus" style="margin-top:8px"></div>
        </div>

        <div id="panelCards" class="panel" style="display:none;margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Cards & Upgrades</strong><div class="small muted">Click a card → Upgrade</div></div>
            <div><button class="ghost" id="resetUpgrades">Reset (dev)</button></div>
          </div>
          <hr style="margin:8px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)"/>
          <div id="cardsList"></div>
        </div>

        <div id="panelChests" class="panel" style="display:none;margin-top:12px">
          <div><strong>Chests & Trophy Road</strong></div>
          <hr style="margin:8px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)"/>
          <div style="display:flex;flex-direction:column;gap:8px">
            <div class="chest">
              <div style="width:56px;height:42px;background:linear-gradient(180deg,#bb8,#fdb);border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#4a2">G</div>
              <div style="flex:1">
                <div><strong>Free Chest</strong></div>
                <div class="small muted">Ready to open</div>
              </div>
              <div><button class="primary" id="openFreeChest">Open</button></div>
            </div>

            <div>
              <div class="small muted">Trophy Road</div>
              <div class="statbar" style="margin-top:6px"><i id="trophyBar" style="width:0%"></i></div>
              <div class="small" style="margin-top:6px">Next reward at <span id="nextTrophy">100</span> trophies</div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div style="height:18px"></div>
    <div class="small muted">Made for testing / learning. Not affiliated with Supercell.</div>
  </div>

<script>
/* Single-file Clash-ish: proper layout + playable, cards + upgrades + chests
   - Bottom (player) vs Top (bot)
   - Click card -> click arena bottom half to deploy
   - Card visuals like cards, upgrade tab works
   - Saves to localStorage
*/

const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const cardsRow = document.getElementById('cardsRow');
const cardsListEl = document.getElementById('cardsList');
const goldDisplay = document.getElementById('goldDisplay');
const trophyDisplay = document.getElementById('trophyDisplay');
const restartBtn = document.getElementById('restartBtn');
const autoPlayBtn = document.getElementById('autoPlayBtn');
const openFreeChestBtn = document.getElementById('openFreeChest');
const matchTimerEl = document.getElementById('matchTimer');
const towerStatusEl = document.getElementById('towerStatus');
const tabBattle = document.getElementById('tabBattle');
const tabCards = document.getElementById('tabCards');
const tabChests = document.getElementById('tabChests');
const panelBattle = document.getElementById('panelBattle');
const panelCards = document.getElementById('panelCards');
const panelChests = document.getElementById('panelChests');
const trophyBar = document.getElementById('trophyBar');
const nextTrophy = document.getElementById('nextTrophy');
const resetUpgradesBtn = document.getElementById('resetUpgrades');

let state = null;
let selectedCardDef = null;
let lastTime = null;
let mouse = {x:0,y:0};
let autoPlay = true;

// Card definitions (visually similar)
const CARD_DEFS = [
  { id:'knight', name:'Knight', cost:3, hp:380, atk:50, range:18, speed:0.9, size:18, type:'melee', color:'#f2c07a', rarity:'common' },
  { id:'archer', name:'Archer', cost:3, hp:150, atk:36, range:140, speed:0.9, size:10, type:'ranged', color:'#8fe7ff', rarity:'common' },
  { id:'giant', name:'Giant', cost:5, hp:1000, atk:90, range:18, speed:0.55, size:26, type:'melee', color:'#ff9b9b', rarity:'rare' },
  { id:'wizard', name:'Wizard', cost:4, hp:220, atk:60, range:130, speed:0.8, size:12, type:'ranged', color:'#cfa6ff', rarity:'epic' }
];

// utility
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// storage
function loadPersist(){
  const raw = localStorage.getItem('clashish-state');
  if (raw) return JSON.parse(raw);
  // default persistent info: gold, trophies, card levels, fragments
  const base = {
    gold: 500,
    trophies: 0,
    cardData: {}, // id -> {level:1,fragments:0}
  };
  CARD_DEFS.forEach(c => base.cardData[c.id] = {level:1, fragments:0});
  return base;
}
function savePersist(){
  const p = { gold: state.persistent.gold, trophies: state.persistent.trophies, cardData: state.persistent.cardData };
  localStorage.setItem('clashish-state', JSON.stringify(p));
}

// game reset (match)
function resetMatch(){
  state.match = {
    running:true,
    time:0,
    elixir:5,
    elixirMax:10,
    lastElixirTick: performance.now(),
    troops: [],
    projectiles: [],
    towers: [],
    bot: {lastDrop:0, dropInterval: 1200 + Math.random()*1000},
    result:null
  };
  // towers bottom (player) - x positions near bottom center left/right
  const gapY = 130;
  const centerX = W/2;
  const leftX = centerX - 240;
  const rightX = centerX + 240;
  // Player (bottom y ~ H-110)
  state.match.towers = [
    { id:'p_left', team:0, x:leftX, y:H-110-gapY, hp:1000, maxHp:1000, range:180, dmg:80, fireRate:1100, lastShot:0, rad:26, isKing:false },
    { id:'p_king', team:0, x:centerX, y:H-110, hp:1800, maxHp:1800, range:210, dmg:100, fireRate:1400, lastShot:0, rad:30, isKing:true },
    { id:'p_right', team:0, x:rightX, y:H-110+gapY, hp:1000, maxHp:1000, range:180, dmg:80, fireRate:1100, lastShot:0, rad:26, isKing:false },
    // Bot (top y ~ 110)
    { id:'b_left', team:1, x:leftX, y:110-gapY, hp:1000, maxHp:1000, range:180, dmg:80, fireRate:1100, lastShot:0, rad:26, isKing:false },
    { id:'b_king', team:1, x:centerX, y:110, hp:1800, maxHp:1800, range:210, dmg:100, fireRate:1400, lastShot:0, rad:30, isKing:true },
    { id:'b_right', team:1, x:rightX, y:110+gapY, hp:1000, maxHp:1000, range:180, dmg:80, fireRate:1100, lastShot:0, rad:26, isKing:false }
  ];
  state.match.troops = [];
  state.match.projectiles = [];
  selectedCardDef = null;
  saveState();
}

// overall state
function resetState(){
  state = {
    persistent: loadPersist(),
    match: null
  };
  resetMatch();
}
function saveState(){ savePersist(); localStorage.setItem('clashish-match', JSON.stringify({})); }

// UI / tabs
tabBattle.addEventListener('click', ()=>{
  tabBattle.classList.add('active'); tabCards.classList.remove('active'); tabChests.classList.remove('active');
  panelBattle.style.display='block'; panelCards.style.display='none'; panelChests.style.display='none';
});
tabCards.addEventListener('click', ()=>{
  tabCards.classList.add('active'); tabBattle.classList.remove('active'); tabChests.classList.remove('active');
  panelCards.style.display='block'; panelBattle.style.display='none'; panelChests.style.display='none';
  renderCardsList();
});
tabChests.addEventListener('click', ()=>{
  tabChests.classList.add('active'); tabBattle.classList.remove('active'); tabCards.classList.remove('active');
  panelChests.style.display='block'; panelBattle.style.display='none'; panelCards.style.display='none';
});

// build card UI (bottom row)
function buildCardsRow(){
  cardsRow.innerHTML = '';
  CARD_DEFS.forEach(def=>{
    const div = document.createElement('div');
    div.className = 'card-ui';
    div.dataset.id = def.id;
    div.innerHTML = `
      <div class="card-thumb" style="background:linear-gradient(180deg, rgba(255,255,255,0.03), transparent);">
        <div style="width:64px;height:44px;border-radius:6px;background:${def.color};display:flex;align-items:center;justify-content:center;color:#04111a;font-weight:800;font-size:16px">
          ${def.name[0]}
        </div>
      </div>
      <div class="card-name">${def.name}</div>
      <div class="card-meta">
        <div class="cost-bubble">${def.cost}</div>
        <div class="small muted">Lv <span class="lvl">${state.persistent.cardData[def.id].level}</span></div>
      </div>
    `;
    div.addEventListener('click', ()=>{
      if (!state.match.running) return;
      if (state.match.elixir < def.cost){ flashTop('Not enough elixir'); return; }
      // select/deselect
      const prev = document.querySelector('.card-ui.selected');
      if (prev) prev.classList.remove('selected');
      if (selectedCardDef && selectedCardDef.id === def.id){ selectedCardDef = null; return; }
      div.classList.add('selected');
      selectedCardDef = def;
    });
    cardsRow.appendChild(div);
  });
}

// card list with upgrades
function renderCardsList(){
  cardsListEl.innerHTML = '';
  CARD_DEFS.forEach(def=>{
    const cd = state.persistent.cardData[def.id];
    const wrapper = document.createElement('div');
    wrapper.style.display='flex'; wrapper.style.alignItems='center'; wrapper.style.justifyContent='space-between'; wrapper.style.marginTop='8px';
    wrapper.innerHTML = `
      <div style="display:flex;gap:8px;align-items:center">
        <div style="width:56px;height:38px;border-radius:8px;background:${def.color};display:flex;align-items:center;justify-content:center;font-weight:800">${def.name[0]}</div>
        <div>
          <div style="font-weight:700">${def.name} <span class="muted" style="font-weight:400">(${def.rarity})</span></div>
          <div class="small muted">Level ${cd.level} · Frags ${cd.fragments}</div>
        </div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <div style="display:flex;gap:6px;align-items:center">
          <div class="small muted">Upgrade cost:</div>
          <div style="background:#0b2b3b;padding:6px 8px;border-radius:8px">${upgradeCost(def.id)} gold</div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="primary" data-id="${def.id}" data-action="upgrade">Upgrade</button>
          <button class="ghost" data-id="${def.id}" data-action="view">View</button>
        </div>
      </div>
    `;
    cardsListEl.appendChild(wrapper);
  });
  // attach upgrade handlers
  cardsListEl.querySelectorAll('button').forEach(b=>{
    b.addEventListener('click', (e)=>{
      const id = b.dataset.id;
      const act = b.dataset.action;
      if (act === 'upgrade') attemptUpgrade(id);
      else alert('Card view - not implemented');
    });
  });
}

// upgrade cost formula
function upgradeCost(cardId){
  const lvl = state.persistent.cardData[cardId].level;
  return Math.floor(80 * Math.pow(1.6, lvl-1)); // grows each level
}

// perform upgrade
function attemptUpgrade(cardId){
  const cost = upgradeCost(cardId);
  if (state.persistent.gold < cost){ flashTop('Not enough gold'); return; }
  // consume gold, raise level, reward fragments maybe
  state.persistent.gold -= cost;
  state.persistent.cardData[cardId].level += 1;
  // small buff: increase base hp/atk by 8%
  const def = CARD_DEFS.find(c=>c.id===cardId);
  def.hp = Math.floor(def.hp * 1.08);
  def.atk = Math.floor(def.atk * 1.08);
  savePersist();
  buildCardsRow();
  renderCardsList();
  updateHUD();
  flashTop(`Upgraded ${def.name} → Lv ${state.persistent.cardData[cardId].level}`);
}

// flash small message on top right (uses match result area)
function flashTop(txt){
  const el = document.createElement('div');
  el.textContent = txt;
  el.style.position='fixed'; el.style.right='18px'; el.style.top='18px'; el.style.background='rgba(0,0,0,0.6)';
  el.style.padding='10px 14px'; el.style.borderRadius='10px'; el.style.color='white'; el.style.zIndex=9999;
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 1200);
}

// build initial state
function init(){
  resetState();
  buildCardsRow();
  renderCardsList();
  updateHUD();
  attachControls();
  requestAnimationFrame(loop);
}

// attach buttons
restartBtn.addEventListener('click', ()=>{
  resetMatch();
  buildCardsRow();
});
autoPlayBtn.addEventListener('click', ()=>{
  autoPlay = !autoPlay;
  autoPlayBtn.textContent = 'Auto Bot: ' + (autoPlay ? 'ON' : 'OFF');
});
openFreeChestBtn.addEventListener('click', ()=>{
  // small random gold + fragments
  const g = rand(40,120);
  state.persistent.gold += g;
  // random fragment to a card
  const pick = CARD_DEFS[rand(0, CARD_DEFS.length-1)].id;
  state.persistent.cardData[pick].fragments += rand(1,4);
  savePersist();
  updateHUD();
  flashTop(`Chest: +${g} gold, +frags to ${pick}`);
});
resetUpgradesBtn.addEventListener('click', ()=>{
  if (!confirm('Reset upgrades to default?')) return;
  state.persistent = { gold:500, trophies:0, cardData:{} };
  CARD_DEFS.forEach(c => state.persistent.cardData[c.id] = { level:1, fragments:0 });
  savePersist();
  buildCardsRow();
  renderCardsList();
  updateHUD();
});

// update HUD elements
function updateHUD(){
  goldDisplay.textContent = Math.floor(state.persistent.gold);
  trophyDisplay.textContent = Math.floor(state.persistent.trophies);
  // trophy bar: next milestone 100 trophies
  const t = state.persistent.trophies;
  const pct = clamp((t % 100) / 100 * 100, 0, 100);
  trophyBar.style.width = pct + '%';
  nextTrophy.textContent = Math.ceil((Math.floor(t/100)+1)*100);
}

// deploy troop (when player clicks on bottom half and selected card)
canvas.addEventListener('mousemove', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = (ev.clientX - rect.left) * (canvas.width / rect.width);
  mouse.y = (ev.clientY - rect.top) * (canvas.height / rect.height);
});
canvas.addEventListener('click', (ev)=>{
  if (!state.match.running) return;
  if (!selectedCardDef) return;
  // allow deploy only in bottom half for player
  if (mouse.y < H/2 + 20){ flashTop('Deploy on your half (bottom)'); return; }
  // spawn near click x, but limited to spawn zone
  const spawnX = clamp(mouse.x, W*0.12, W*0.88);
  const spawnY = clamp(mouse.y, H*0.55, H-120);
  // ensure enough elixir
  if (state.match.elixir < selectedCardDef.cost){ flashTop('Not enough elixir'); return; }
  // create troop with level scaling
  const persistent = state.persistent.cardData[selectedCardDef.id];
  const lvlMult = 1 + (persistent.level - 1) * 0.07;
  const troop = {
    id: selectedCardDef.id + '-' + Math.random().toString(36).slice(2,7),
    defId: selectedCardDef.id,
    name: selectedCardDef.name,
    x: spawnX, y: spawnY,
    team: 0,
    hp: Math.floor(selectedCardDef.hp * lvlMult),
    maxHp: Math.floor(selectedCardDef.hp * lvlMult),
    atk: Math.floor(selectedCardDef.atk * lvlMult),
    range: selectedCardDef.range,
    speed: selectedCardDef.speed,
    size: selectedCardDef.size,
    type: selectedCardDef.type,
    target: null,
    lastAttack: 0,
    atkSpeed: 800
  };
  state.match.troops.push(troop);
  state.match.elixir -= selectedCardDef.cost;
  selectedCardDef = null;
  document.querySelectorAll('.card-ui').forEach(c=>c.classList.remove('selected'));
});

// deploy for bot
function botDeploy(now){
  if (!autoPlay) return;
  const bot = state.match.bot;
  if (now - bot.lastDrop > bot.dropInterval){
    // choose random card affordable
    const affordable = CARD_DEFS.filter(c => c.cost <= state.match.elixir + 2); // bot has flexible assumption
    if (affordable.length){
      const pick = affordable[rand(0, affordable.length-1)];
      // spawn in top half (bot)
      const x = rand(W*0.2, W*0.8);
      const y = rand(90, H*0.45);
      // create troop (bot level ~= player's avg level)
      const playerAvgLevel = Object.values(state.persistent.cardData).reduce((a,b)=>a+b.level,0) / CARD_DEFS.length;
      const lvlMult = 1 + (Math.floor(playerAvgLevel)-1)*0.06;
      const troop = {
        id: pick.id + '-b-' + Math.random().toString(36).slice(2,6),
        defId: pick.id,
        name: pick.name,
        x,y, team:1,
        hp: Math.floor(pick.hp * lvlMult),
        maxHp: Math.floor(pick.hp * lvlMult),
        atk: Math.floor(pick.atk * lvlMult),
        range: pick.range,
        speed: -pick.speed, // negative to go downward
        size: pick.size,
        type: pick.type,
        target:null,
        lastAttack:0,
        atkSpeed:800
      };
      state.match.troops.push(troop);
      bot.lastDrop = now;
      bot.dropInterval = 900 + Math.random()*1400;
    }
  }
}

// simple find nearest enemy for a unit
function findNearest(unit){
  let nearest = null, best = 1e9;
  // check troops and towers
  for (const t of state.match.troops.concat(state.match.towers)){
    if (t === unit) continue;
    if (t.team === unit.team) continue;
    const d = Math.hypot(t.x - unit.x, t.y - unit.y);
    if (d < best){ best = d; nearest = t; }
  }
  return {target: nearest, dist: best};
}

// towers shoot as projectiles
function towerShooting(now){
  for (const tw of state.match.towers){
    if (tw.hp <= 0) continue;
    if (now - tw.lastShot < tw.fireRate) continue;
    // find nearest enemy troop or tower
    const enemies = state.match.troops.concat(state.match.towers.filter(t=>t.team!==tw.team && t.hp>0));
    let target = null, best = 1e9;
    for (const e of enemies){
      if (e.team === tw.team) continue;
      const d = Math.hypot(e.x - tw.x, e.y - tw.y);
      if (d < best){ best = d; target = e; }
    }
    if (target && best <= tw.range){
      // create projectile
      const pr = { x: tw.x, y: tw.y, tx: target.x, ty: target.y, vx: (target.x-tw.x)/Math.max(1,best)*6, vy:(target.y-tw.y)/Math.max(1,best)*6, dmg:tw.dmg, team:tw.team, born:now, life:2500 };
      state.match.projectiles.push(pr);
      tw.lastShot = now;
    }
  }
}

// troops behavior
function troopsThink(now, dt){
  for (const u of state.match.troops){
    if (u.hp <= 0) continue;
    // find nearest enemy
    const list = state.match.troops.concat(state.match.towers.filter(t=>t.team!==u.team && t.hp>0));
    let target = null, best = 1e9;
    for (const e of list){
      if (e.team === u.team) continue;
      const d = Math.hypot(e.x - u.x, e.y - u.y);
      if (d < best){ best = d; target = e; }
    }
    if (target && best <= u.range + (u.size||10) + (target.rad||10) ){
      // attack if cooldown ready
      if (now - u.lastAttack >= u.atkSpeed){
        // apply damage (for ranged, spawn instant projectile)
        if (u.type === 'ranged'){
          // direct hit projectile (fast)
          const proj = { x:u.x, y:u.y, tx:target.x, ty:target.y, vx:(target.x-u.x)/Math.max(1,best)*7, vy:(target.y-u.y)/Math.max(1,best)*7, dmg:u.atk, team:u.team, born:now, life:1500 };
          state.match.projectiles.push(proj);
        } else {
          // melee: instant reduce
          target.hp -= u.atk;
        }
        u.lastAttack = now;
      }
      // melee stops moving; ranged might kite a little (we skip complex AI)
    } else {
      // move forward along team direction: player = up (negative y), bot = down (positive y)
      const dir = u.team === 0 ? -1 : 1;
      u.y += u.speed * dt * 0.05 * (u.team===0 ? -1 : 1); // speeds are positive, adjust sign
      // clamp inside arena
      u.y = clamp(u.y, 80, H-80);
      // slight horizontal drift based on spawn
      // (no obstacles)
    }
  }
  // remove massively dead troops after a bit
  state.match.troops = state.match.troops.filter(t => !(t.hp <= -800));
}

// projectiles
function projectilesThink(now){
  for (const p of state.match.projectiles){
    p.x += p.vx;
    p.y += p.vy;
    if (now - p.born > p.life) p.dead = true;
    // collision
    const targets = state.match.troops.concat(state.match.towers.filter(t=>t.team!==p.team && t.hp>0));
    for (const t of targets){
      const d = Math.hypot(t.x - p.x, t.y - p.y);
      const hitR = (t.size || t.rad || 10) + 6;
      if (d <= hitR){
        t.hp -= p.dmg;
        p.dead = true;
        break;
      }
    }
  }
  state.match.projectiles = state.match.projectiles.filter(p => !p.dead);
}

// cleanup dead troops visible a bit
function cleanupDead(now){
  state.match.troops = state.match.troops.filter(t=>{
    if (t.hp <= 0){
      t.diedAt = t.diedAt || now;
      if (now - t.diedAt > 800) return false;
    }
    return true;
  });
}

// check victory
function checkEnd(){
  const playerKing = state.match.towers.find(t=>t.team===0 && t.isKing);
  const botKing = state.match.towers.find(t=>t.team===1 && t.isKing);
  if (playerKing.hp <= 0){
    endMatch(false, 'King tower destroyed');
  } else if (botKing.hp <= 0){
    endMatch(true, 'Enemy king destroyed');
  }
  // side towers
  const playerAlive = state.match.towers.some(t=>t.team===0 && t.hp>0);
  const botAlive = state.match.towers.some(t=>t.team===1 && t.hp>0);
  if (!playerAlive) endMatch(false, 'All player towers down');
  if (!botAlive) endMatch(true, 'All enemy towers down');
}

function endMatch(win, reason){
  if (!state.match.running) return;
  state.match.running = false;
  state.match.result = { win, reason };
  // reward
  if (win){
    state.persistent.gold += 140 + rand(0,80);
    state.persistent.trophies += 16;
  } else {
    state.persistent.gold += 20 + rand(0,20);
    state.persistent.trophies = Math.max(0, state.persistent.trophies - 8);
  }
  // small chance fragments
  const fragCard = CARD_DEFS[rand(0,CARD_DEFS.length-1)].id;
  state.persistent.cardData[fragCard].fragments += rand(0,3);
  savePersist();
  updateHUD();
  flashTop((win ? 'Victory! ' : 'Defeat. ') + reason);
}

// drawing
function render(){
  // background
  ctx.clearRect(0,0,W,H);
  // base
  ctx.fillStyle = '#042c3a';
  ctx.fillRect(0,0,W,H);
  // river middle
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(W*0.18, H*0.45, W*0.64, H*0.1);
  // center line
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,H/2-1, W, 2);
  // lanes (visual)
  ctx.strokeStyle = 'rgba(255,255,255,0.015)';
  ctx.lineWidth = 1;
  [H*0.25, H*0.5, H*0.75].forEach(y=>{
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  });

  // towers
  for (const t of state.match.towers){
    if (t.hp <= 0) continue;
    // base ring
    ctx.beginPath();
    ctx.fillStyle = t.team===0 ? '#2fb07f' : '#ff5a6a';
    ctx.arc(t.x, t.y, t.rad, 0, Math.PI*2);
    ctx.fill();
    if (t.isKing){
      // crown decoration
      ctx.fillStyle = '#ffd66b';
      ctx.fillRect(t.x-10, t.y- t.rad - 16, 20, 6);
    }
    // hp bar
    const pct = clamp(t.hp / t.maxHp, 0, 1);
    ctx.fillStyle = '#072434';
    ctx.fillRect(t.x - 44, t.y - t.rad - 18, 88, 10);
    ctx.fillStyle = '#1f9fff';
    ctx.fillRect(t.x - 44, t.y - t.rad - 18, 88 * pct, 10);
  }

  // troops
  for (const u of state.match.troops){
    ctx.globalAlpha = u.hp > 0 ? 1 : 0.35;
    if (u.type === 'melee'){
      // rounded square
      ctx.fillStyle = u.team===0 ? '#f2c07a' : '#ff9b9b';
      roundRect(ctx, u.x - u.size, u.y - u.size, u.size*2, u.size*2, 6, true);
    } else {
      // circle with simple gradient
      const grd = ctx.createLinearGradient(u.x - 10, u.y - 10, u.x + 10, u.y + 10);
      grd.addColorStop(0, u.team===0 ? '#8fe7ff' : '#cfa6ff');
      grd.addColorStop(1, u.team===0 ? '#9ddfff' : '#e0c6ff');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(u.x, u.y, u.size, 0, Math.PI*2); ctx.fill();
    }
    // hp bar
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#072434';
    ctx.fillRect(u.x - u.size, u.y - u.size - 10, u.size*2, 5);
    ctx.fillStyle = '#33d';
    const p = clamp(u.hp / u.maxHp, 0, 1);
    ctx.fillRect(u.x - u.size, u.y - u.size - 10, (u.size*2) * p, 5);
  }

  // projectiles
  for (const p of state.match.projectiles){
    ctx.beginPath();
    ctx.fillStyle = p.team===0 ? '#29f' : '#f44';
    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
    ctx.fill();
  }

  // selected card hover indicator
  if (selectedCardDef){
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 24, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '12px Inter';
    ctx.fillText(selectedCardDef.name + ' • ' + selectedCardDef.cost, mouse.x+26, mouse.y+6);
  }
}

function roundRect(ctx, x, y, w, h, r, fill){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
}

// main loop
function loop(now){
  if (!lastTime) lastTime = now;
  const dt = now - lastTime;
  lastTime = now;
  if (!state.match) resetMatch();
  // if running:
  if (state.match.running){
    state.match.time += dt;
    // elixir regen: every 800ms -> +1
    if (now - state.match.lastElixirTick > 800){
      if (state.match.elixir < state.match.elixirMax) state.match.elixir++;
      state.match.lastElixirTick = now;
    }
    // bot deploy
    botDeploy(now);
    // towers shoot
    towerShooting(now);
    // troops behavior
    troopsThink(now, dt);
    // projectiles
    projectilesThink(now);
    // cleanup
    cleanupDead(now);
    // check end
    checkEnd();
  }
  // update HUD
  matchTimerEl.textContent = formatTime(Math.floor(state.match.time/1000));
  updateTowerList();
  render();
  requestAnimationFrame(loop);
}

function updateTowerList(){
  // show bars
  towerStatusEl.innerHTML = '';
  const labels = ['Player left','Player king','Player right','Bot left','Bot king','Bot right'];
  state.match.towers.forEach((t,i)=>{
    const pct = Math.max(0, Math.floor((t.hp / t.maxHp)*100));
    const row = document.createElement('div');
    row.style.marginBottom='8px';
    row.innerHTML = `<div style="display:flex;justify-content:space-between"><div class="small">${labels[i]}</div><div class="small muted">${pct}%</div></div>
      <div class="statbar" style="margin-top:6px"><i style="width:${pct}%"></i></div>`;
    towerStatusEl.appendChild(row);
  });
}

function formatTime(sec){
  const mm = String(Math.floor(sec/60)).padStart(2,'0');
  const ss = String(sec%60).padStart(2,'0');
  return mm+':'+ss;
}

// initial build & HUD update
function attachControls(){
  buildCardsRow();
  renderCardsList();
  updateHUD();
}
function savePersist(){
  // save persistent object
  savePersist(); // calls savePersist defined earlier
}
function savePersist(){ // redefined for lexical
  state.persistent && localStorage.setItem('clashish-state', JSON.stringify({
    gold: state.persistent.gold,
    trophies: state.persistent.trophies,
    cardData: state.persistent.cardData
  }));
}

function saveAndUpdate(){
  savePersist();
  updateHUD();
}

// init persistent storage and match state
function resetState(){
  state = { persistent: loadPersist(), match: null };
}
function resetAndStart(){
  resetState();
  resetMatch();
  buildCardsRow();
  renderCardsList();
  updateHUD();
}

// initial load
resetAndStart();
requestAnimationFrame(loop);

// expose some helpers for upgrade cost usage
function upgradeCost(cardId){
  return Math.floor(80 * Math.pow(1.6, state.persistent.cardData[cardId].level - 1));
}

// attemptUpgrade wrapper we used earlier in UI
function attemptUpgrade(cardId){
  const cost = upgradeCost(cardId);
  if (state.persistent.gold < cost){ flashTop('Need more gold'); return; }
  state.persistent.gold -= cost;
  state.persistent.cardData[cardId].level += 1;
  // small stat boost: multiply base defs stored in CARD_DEFS
  const def = CARD_DEFS.find(c=>c.id===cardId);
  def.hp = Math.floor(def.hp * 1.07);
  def.atk = Math.floor(def.atk * 1.07);
  savePersist();
  buildCardsRow();
  renderCardsList();
  updateHUD();
  flashTop(`Upgraded ${def.name} to Lv ${state.persistent.cardData[cardId].level}`);
}

// small helper to expose functions inside this scope for UI buttons
window.attemptUpgrade = attemptUpgrade;

</script>
</body>
</html>
